<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AUTHORS" xml:space="preserve">
    <value>Merci de laisser votre adresse email en commentaire</value>
  </data>
  <data name="board_fw_version" xml:space="preserve">
    <value>Version du firmware de la carte</value>
  </data>
  <data name="bootloader_mode" xml:space="preserve">
    <value>Mode "Bootloader"</value>
  </data>
  <data name="connected_bl_mode" xml:space="preserve">
    <value>Connecté au FlashcatUSB en mode "bootloader"</value>
  </data>
  <data name="connected_fw_ver" xml:space="preserve">
    <value>Connecté à {0}, version firmware: {1}</value>
  </data>
  <data name="console_complete" xml:space="preserve">
    <value>Application terminée</value>
    <comment>Shown after the console mode has completed</comment>
  </data>
  <data name="mem_erasing_device" xml:space="preserve">
    <value>Effacement en cours de la mémoire Flash... (peut prendre 2 minutes)</value>
  </data>
  <data name="console_exescript_req" xml:space="preserve">
    <value>L'opération "ExecuteScript" nécessite l'option  -FILE pour indiquer quel fichier de script exécuter</value>
  </data>
  <data name="console_i2c_params" xml:space="preserve">
    <value>Paramètres I2C : adresse esclave 0x{0}, décalage: 0x{1}, longueur: {2} octets</value>
  </data>
  <data name="console_i2c_reading" xml:space="preserve">
    <value>Lecture des données en provenance du circuit flash I2C: {0} ({1} octets)</value>
  </data>
  <data name="console_i2c_saved" xml:space="preserve">
    <value>Enregistrement des données I2C sur: {0}</value>
  </data>
  <data name="console_i2c_write_error" xml:space="preserve">
    <value>Erreur: Impossible d'écrire sur l'EEPROM I2C</value>
  </data>
  <data name="console_i2c_write_success" xml:space="preserve">
    <value>L'écriture sur l' EEPROM I2C s'est correctement déroulée</value>
  </data>
  <data name="console_i2c_writing" xml:space="preserve">
    <value>Ecriture des données sur le circuit flash I2C en cours: {0} ({1} octets)</value>
  </data>
  <data name="console_logappend" xml:space="preserve">
    <value>Ajoute le texte de la console au fichier texte existant</value>
  </data>
  <data name="console_mode_not_specified" xml:space="preserve">
    <value>MODE non spécifié (i.e. -SPI ou -I2C)</value>
  </data>
  <data name="console_no_fcusb" xml:space="preserve">
    <value>Aucun circuit FlashcatUSB connecté</value>
  </data>
  <data name="console_no_mem_devices" xml:space="preserve">
    <value>Impossible d'effectuer toute action car aucun circuit de mémoire n'est détecté</value>
  </data>
  <data name="console_operation_not_specified" xml:space="preserve">
    <value>OPERATION non spécifiée (i.e. -READ ou -WRITE)</value>
  </data>
  <data name="console_opt_addr" xml:space="preserve">
    <value>Spécifie l'adresse esclave I2C (i.e. 0xA0)</value>
  </data>
  <data name="console_opt_eeprom" xml:space="preserve">
    <value>Spécifie une EEPROM SPI/I2C (i.e. M95080 or 24XX64)</value>
  </data>
  <data name="console_opt_erase" xml:space="preserve">
    <value>Effectue un effacement de toute la mémoire avant d'écrire les données</value>
  </data>
  <data name="console_opt_exe" xml:space="preserve">
    <value>Permet d'exécution d'un fichier script FlashcatUSB (*.fcs)</value>
  </data>
  <data name="console_opt_exit" xml:space="preserve">
    <value>Ferme automatiquement la fenêtre à la fin</value>
  </data>
  <data name="console_opt_file" xml:space="preserve">
    <value>Spécifie le fichier à utiliser pour lire/écrire/exécuter</value>
  </data>
  <data name="console_opt_help" xml:space="preserve">
    <value>Affiche ce message</value>
    <comment>text seen in the console help menu</comment>
  </data>
  <data name="console_opt_length" xml:space="preserve">
    <value>Spécifie le nombre d'octets à lire/écrire</value>
  </data>
  <data name="console_opt_list" xml:space="preserve">
    <value>Affiche le chemin USB pour tous les circuits FlashcatUSB connectés</value>
  </data>
  <data name="console_opt_log" xml:space="preserve">
    <value>Enregistre les sorties de la console dans un fichier</value>
  </data>
  <data name="console_opt_offset" xml:space="preserve">
    <value>Spécifie le décalage pour l'écriture du fichier dans la mémoire flash</value>
  </data>
  <data name="console_opt_path" xml:space="preserve">
    <value>Select which FlashcatUSB to use (use quotes around path)</value>
  </data>
  <data name="console_opt_read" xml:space="preserve">
    <value>Effectue une opération de lecture de la mémoire flash</value>
  </data>
  <data name="console_opt_verify" xml:space="preserve">
    <value>Supprime la vérification après une opération d'écriture sur la mémoire</value>
  </data>
  <data name="console_opt_write" xml:space="preserve">
    <value>Effectue une opération d'écriture de la mémoire flash</value>
  </data>
  <data name="console_progress" xml:space="preserve">
    <value>[{0}% effectué]</value>
    <comment>Progress bar for the console window</comment>
  </data>
  <data name="console_readmem_req" xml:space="preserve">
    <value>L'opération "ReadMemory" nécessite l'option -FILE pour indiquer dans quel fichier enregistrer les données</value>
  </data>
  <data name="console_read_err_nodata" xml:space="preserve">
    <value>Erreur: La lecture a échoué car il n'y a pas de donnée à lire</value>
  </data>
  <data name="console_usb_list" xml:space="preserve">
    <value>Liste des chemins USB des FlashcatUSB connectés</value>
  </data>
  <data name="console_writemem_req" xml:space="preserve">
    <value>L'opération "WriteMemory" nécessite l'option -FILE pour indiquer dans quel fichier enregistrer les données</value>
  </data>
  <data name="console_write_err_nodata" xml:space="preserve">
    <value>Erreur: L'écriture a échoué car il n'y a pas de donnée à écrire</value>
  </data>
  <data name="detecting_device" xml:space="preserve">
    <value>Détection de la mémoire flash connectée en cours</value>
  </data>
  <data name="device_mode" xml:space="preserve">
    <value>Mode du circuit</value>
  </data>
  <data name="device_mode_i2c" xml:space="preserve">
    <value>Mode EEPROM I2C. Configurer les paramètres I2C puis cliquer 'Détection'</value>
  </data>
  <data name="disconnected_from_device" xml:space="preserve">
    <value>Déconnecté du {0} circuit</value>
  </data>
  <data name="error_file_not_found" xml:space="preserve">
    <value>Erreur, fichier non trouvé: {0}</value>
  </data>
  <data name="err_file_not_found" xml:space="preserve">
    <value>Erreur, fichier non trouvé</value>
  </data>
  <data name="err_unable_to_connect" xml:space="preserve">
    <value>Erreur: Impossible de se connecter au FlashcatUSB</value>
  </data>
  <data name="ext_4mbit_device" xml:space="preserve">
    <value>Détection d'un circuit DIP32/PLCC32 de 4MBIT, activation de A18 sur la pin 1 (reset)</value>
  </data>
  <data name="ext_board_initalized" xml:space="preserve">
    <value>La carte EXT I/O a été initialisée correctement</value>
  </data>
  <data name="ext_board_not_detected" xml:space="preserve">
    <value>Impossible de se connecter à la carte d'extension I/O</value>
  </data>
  <data name="ext_connected_chipid" xml:space="preserve">
    <value>Connecté à la Flash (CHIP ID: 0x{0})</value>
  </data>
  <data name="ext_detecting_device" xml:space="preserve">
    <value>Tentative de détecter automatiquement la mémoire flash</value>
  </data>
  <data name="ext_device_detected" xml:space="preserve">
    <value>Circuit détecté avec succès en mode {0}</value>
  </data>
  <data name="ext_device_interface" xml:space="preserve">
    <value>Interface du circuit</value>
  </data>
  <data name="ext_init" xml:space="preserve">
    <value>Initialisation de la carte EXT I/O</value>
  </data>
  <data name="ext_large_flash_detected" xml:space="preserve">
    <value>Notification: {0} circuit détecté, Le port d'extension ne peut accéder que jusqu'à 512 Mb</value>
  </data>
  <data name="ext_not_detected" xml:space="preserve">
    <value>Circuit flash non détecté en mode extension I/O</value>
  </data>
  <data name="ext_page_size" xml:space="preserve">
    <value>Taille des pages flash: {0} octets ({1} octets étendu)</value>
  </data>
  <data name="ext_prog_mode" xml:space="preserve">
    <value>Mode de programmation: EXT I/O (Parallèle)</value>
  </data>
  <data name="ext_unable_to_connect_to_board" xml:space="preserve">
    <value>Erreur: impossible de connecter à la carte EXT I/O au travers du SPI</value>
  </data>
  <data name="ext_write_mode_supported" xml:space="preserve">
    <value>Mode d'écriture supporté</value>
  </data>
  <data name="flash_detected" xml:space="preserve">
    <value>Flash détecté: {0} ({1} octets)</value>
  </data>
  <data name="fw_feat_supported" xml:space="preserve">
    <value>Fonctionnalités du Firmware supportées</value>
  </data>
  <data name="fw_out_of_date" xml:space="preserve">
    <value>Le firmware du FlashcatUSB est périmé, merci de le mettre à jour</value>
  </data>
  <data name="fw_update_available" xml:space="preserve">
    <value>Mise à jour du Firmware disponible, mise à jour en cours</value>
  </data>
  <data name="fw_update_error" xml:space="preserve">
    <value>Erreur: échec du démarrage de la mise à jour du firmware</value>
  </data>
  <data name="fw_update_performing" xml:space="preserve">
    <value>Mise à jour du firmware en cours</value>
  </data>
  <data name="fw_update_programming" xml:space="preserve">
    <value>Programmation du nouveau firmware dans le FlashcatUSB</value>
  </data>
  <data name="fw_update_starting" xml:space="preserve">
    <value>La mise à jour du firmware démarre (envoie de {0} octets)</value>
  </data>
  <data name="i2c_addr_byte" xml:space="preserve">
    <value>I2C Octet d'adresse: 0x{0}</value>
    <comment>I2C EEPROM ADDRESS</comment>
  </data>
  <data name="i2c_attempt_detect" xml:space="preserve">
    <value>Tentative de détecter le circuit EEPROM I2C </value>
  </data>
  <data name="i2c_connected" xml:space="preserve">
    <value>Connexion réussie avec le circuit EEPROM I2C</value>
  </data>
  <data name="i2c_detected" xml:space="preserve">
    <value>EEPROM I2C détectée et prête pour les opérations</value>
  </data>
  <data name="i2c_eeprom_size" xml:space="preserve">
    <value>Taille du circuit EEPROM I2C: {0} octets</value>
  </data>
  <data name="i2c_not_detected" xml:space="preserve">
    <value>Circuit EEPROM I2C non détecté</value>
  </data>
  <data name="i2c_protocol_speed" xml:space="preserve">
    <value>Vitesse du protocole I2C</value>
  </data>
  <data name="i2c_unable_to_connect" xml:space="preserve">
    <value>Impossible de se connecter à la EEPROM I2C</value>
  </data>
  <data name="jtag_cfi_attempt_detect" xml:space="preserve">
    <value>Tentative de détection de la flash CFI flash à l'adresse 0x{0}</value>
  </data>
  <data name="jtag_cfi_no_detect" xml:space="preserve">
    <value>Erreur: impossible de détecter le circuit flash au travers du JTAG</value>
  </data>
  <data name="jtag_dma" xml:space="preserve">
    <value>Le circuit cible est compatible avec le mode DMA</value>
  </data>
  <data name="jtag_dma_not_supported" xml:space="preserve">
    <value>Erreur: Le MCU n'est pas compatible d'un accès DMA aux registres</value>
  </data>
  <data name="jtag_failed_to_connect" xml:space="preserve">
    <value>Echec de la connexion à la carte cible via JTAG</value>
  </data>
  <data name="jtag_no_dma" xml:space="preserve">
    <value>Circuit cible non compatible du mode DMA</value>
  </data>
  <data name="jtag_no_idcode" xml:space="preserve">
    <value>Le circuit ne renvoie pas l' IDCODE</value>
  </data>
  <data name="jtag_ready" xml:space="preserve">
    <value>{0} prêt pour opérer en mode JTAG</value>
  </data>
  <data name="jtag_setup" xml:space="preserve">
    <value>Moteur JTAG configuré avec succès</value>
  </data>
  <data name="jtag_spi_api_not_loaded" xml:space="preserve">
    <value>Logiciel non compatible avec MCU pour des opérations SPI</value>
  </data>
  <data name="jtag_spi_attempt_detect" xml:space="preserve">
    <value>Tentative de détection de la flash CFI flash connectée au MCU au travers du JTAG</value>
  </data>
  <data name="jtag_spi_no_detect" xml:space="preserve">
    <value>Erreur: Impossible de détecter la flash SPI au travers du JTAG</value>
  </data>
  <data name="jtag_unknown_device" xml:space="preserve">
    <value>Circuit JTAG inconnu</value>
  </data>
  <data name="mem_ask_continue" xml:space="preserve">
    <value>Poursuivre les opérations d'écriture ?</value>
  </data>
  <data name="mem_bad_nand_block" xml:space="preserve">
    <value>Mauvais bloc NAND à la page index: 0x{0} (bloc index: {1})</value>
  </data>
  <data name="mem_erase_device" xml:space="preserve">
    <value>Effacement complet en cours</value>
  </data>
  <data name="mem_erase_device_fail" xml:space="preserve">
    <value>Erreur: l'effacement du circuit a échoué</value>
  </data>
  <data name="mem_erase_device_success" xml:space="preserve">
    <value>Circuit mémoire correctement effacé</value>
  </data>
  <data name="mem_erasing_sector" xml:space="preserve">
    <value>Effacement d'un secteur mémoire</value>
  </data>
  <data name="mem_flash_supported" xml:space="preserve">
    <value>Circuit flash détecté correctement et prêt pour les opérations</value>
  </data>
  <data name="mem_i2c_error" xml:space="preserve">
    <value>Erreur de communication avec le circuit I2C</value>
  </data>
  <data name="mem_not_supported" xml:space="preserve">
    <value>Mémoire flash détectée mais absente de la bibliothèque des circuits</value>
  </data>
  <data name="mem_reading_memory" xml:space="preserve">
    <value>Lecture de  {0} octets en mémoire</value>
  </data>
  <data name="mem_verify_data" xml:space="preserve">
    <value>Vérification des données écrites</value>
  </data>
  <data name="mem_verify_failed" xml:space="preserve">
    <value>Echec de la vérification des données!</value>
  </data>
  <data name="mem_verify_failed_at" xml:space="preserve">
    <value>La vérification des données a échouée à 0x{0}</value>
  </data>
  <data name="mem_verify_failed_title" xml:space="preserve">
    <value>Erreur: Echec de la vérification</value>
  </data>
  <data name="mem_verify_mismatches" xml:space="preserve">
    <value>Adresse {0}:  {1} écrit mais {2} lu ({3} différences)</value>
  </data>
  <data name="mem_verify_okay" xml:space="preserve">
    <value>Succès de la vérification des données</value>
  </data>
  <data name="mem_write_not_successful" xml:space="preserve">
    <value>Erreur: Echec de l'écriture des données</value>
  </data>
  <data name="mem_write_successful" xml:space="preserve">
    <value>Succès de l'opération d'écriture</value>
  </data>
  <data name="mem_writing_memory" xml:space="preserve">
    <value>Ecriture de {0} octets en mémoire</value>
  </data>
  <data name="nand_block_manager_disabled" xml:space="preserve">
    <value>Gestionnaire de blocs NAND désactivé</value>
  </data>
  <data name="nand_erase_failed" xml:space="preserve">
    <value>Erreur lors de l'effacement du circuit NAND</value>
  </data>
  <data name="nand_erase_successful" xml:space="preserve">
    <value>Circuit flash NAND correctement effacé</value>
  </data>
  <data name="nand_mem_device_detected" xml:space="preserve">
    <value>Mémoire NAND détectée, chargement de la carte mémoire</value>
  </data>
  <data name="nand_mem_map_complete" xml:space="preserve">
    <value>Fin du chargement de la carte mémoire NAND: {0} pages disponibles pour accès</value>
  </data>
  <data name="nand_mem_map_loading" xml:space="preserve">
    <value>Chargement de la carte mémoire NAND valide</value>
  </data>
  <data name="no_flash_detected" xml:space="preserve">
    <value>Aucune Flash détectée</value>
  </data>
  <data name="spinand_connected" xml:space="preserve">
    <value>Connecté à une SPI NAND Flash (RDID:{0})</value>
  </data>
  <data name="spinand_flash_size" xml:space="preserve">
    <value>Flash détectée: {0} ({1} octets)</value>
  </data>
  <data name="spinand_opened_device" xml:space="preserve">
    <value>Circuit ouvert correctement en mode SPI NAND</value>
  </data>
  <data name="spinand_page_size" xml:space="preserve">
    <value>Taille de la page flash: {0} octets ({1} octets étendu)</value>
  </data>
  <data name="spi_attempting_detect" xml:space="preserve">
    <value>tentative de détection du circuit SPI (mode de détection automatique)</value>
  </data>
  <data name="spi_connected_to_flash_spi" xml:space="preserve">
    <value>Connecté à la SPI Flash (RDID:{0} REMS:{1})</value>
  </data>
  <data name="spi_connected_to_flash_sqi" xml:space="preserve">
    <value>Connecté à la SQI Flash (RDID:{0})</value>
  </data>
  <data name="spi_detected_ls_spi" xml:space="preserve">
    <value>Circuit SPI Flash détecté sur le port SPI basse vitesse</value>
  </data>
  <data name="spi_detected_spi" xml:space="preserve">
    <value>Circuit SPI Flash détecté sur le port SPI haute vitesse</value>
  </data>
  <data name="spi_detected_sqi" xml:space="preserve">
    <value>Circuit SPI Flash détecté sur le port SQI</value>
  </data>
  <data name="spi_device_not_found_sqi" xml:space="preserve">
    <value>Circuit ouvert en mode SQI mais absent de la bibliothèque flash</value>
  </data>
  <data name="spi_device_opened" xml:space="preserve">
    <value>Circuit ouvert correctement en mode SPI</value>
  </data>
  <data name="spi_eeprom_cfg" xml:space="preserve">
    <value>Configuré pour utiliser le circuit EEPROM SPI</value>
  </data>
  <data name="spi_erase_complete" xml:space="preserve">
    <value>Effacement Flash terminé en {0} secondes</value>
  </data>
  <data name="spi_erasing_die" xml:space="preserve">
    <value>Effacement du l'index  de la matrice flash: {0} ({1} octets)</value>
  </data>
  <data name="spi_erasing_flash_device" xml:space="preserve">
    <value>Effacement complet du circuit flash, taille totale: {0} octets (cela peut prendre un certain temps)</value>
  </data>
  <data name="spi_error_reading" xml:space="preserve">
    <value>SPI: Erreur de lecture de données depuis le port USB</value>
  </data>
  <data name="spi_error_writing" xml:space="preserve">
    <value>SPI: Erreur d'écriture de données depuis le port USB</value>
  </data>
  <data name="spi_flash_not_detected" xml:space="preserve">
    <value>Impossible de détecter un circuit SPI compatible</value>
  </data>
  <data name="spi_flash_page_size" xml:space="preserve">
    <value>Effacement de page taille: {0} octets</value>
  </data>
  <data name="spi_mode_sqi" xml:space="preserve">
    <value>Mode de programmation: SQI (SPI-QUAD)</value>
  </data>
  <data name="spi_nand_attempt_detect" xml:space="preserve">
    <value>Tentative de détection d'un circuit SPI NAND</value>
  </data>
  <data name="spi_nand_detected" xml:space="preserve">
    <value>Circuit SPI NAND Flash détecté avec succès</value>
  </data>
  <data name="spi_nand_unable_to_detect" xml:space="preserve">
    <value>Impossible de détecter le circuit  SPI NAND</value>
  </data>
  <data name="spi_not_detected" xml:space="preserve">
    <value>Mémoire flash non détectée en mode SPI NOR</value>
  </data>
  <data name="spi_set_clock" xml:space="preserve">
    <value>Valeur de l'horloge SPI: {0}</value>
  </data>
  <data name="spi_successfully_opened_sqi" xml:space="preserve">
    <value>Circuit ouvert avec succès en mode SQI </value>
  </data>
  <data name="spi_unable_detect" xml:space="preserve">
    <value>Impossible de détecteur un circuit SPI NOR</value>
  </data>
  <data name="successfully_connected" xml:space="preserve">
    <value>FlashcatUSB connecté avec succès sur port USB</value>
  </data>
  <data name="sw_requires_fw" xml:space="preserve">
    <value>Le logiciel nécessite la version {0} du firmware</value>
  </data>
  <data name="unknown_device_email" xml:space="preserve">
    <value>Pour compatibilité avec ce circuit contacter contact@embeddedcomputers.net en indiquant le CHIP ID</value>
  </data>
  <data name="usb_driver_out_of_date" xml:space="preserve">
    <value>Votre driver FlashcatUSB est obsolète. Merci de mettre à jour votre driver avec la version plus récente incluse avec cette distribution du logiciel</value>
  </data>
  <data name="usb_firm_out_of_date" xml:space="preserve">
    <value>Votre firmware FlashcatUSB est obsolète, merci de le mettre à jour avec la version incluse avec cette distribution du logiciel</value>
  </data>
  <data name="voltage_set_to" xml:space="preserve">
    <value>Tension sélectionnée: {0}</value>
  </data>
  <data name="welcome_to_flashcatusb" xml:space="preserve">
    <value>Bienvenue sur le logiciel d'interfaçage du FlashcatUSB</value>
  </data>
  <data name="gui_active_script" xml:space="preserve">
    <value>Active script</value>
    <comment>Label for the form</comment>
  </data>
  <data name="gui_compressed_img" xml:space="preserve">
    <value>Fichier d'archive compressé</value>
  </data>
  <data name="gui_console_text_copied" xml:space="preserve">
    <value>Texte de la console copié dans le presse papier</value>
  </data>
  <data name="gui_creating_nand_file" xml:space="preserve">
    <value>Création d'un fichier de l'image du NAND flash</value>
  </data>
  <data name="gui_database_supported" xml:space="preserve">
    <value>{0} base de donnée chargée: {1} circuits compatibles</value>
    <comment>Displays how many flash devices the database contains</comment>
  </data>
  <data name="gui_fcusb_connected" xml:space="preserve">
    <value>FlashcatUSB statut: Connecté</value>
  </data>
  <data name="gui_fcusb_connected_multi" xml:space="preserve">
    <value>FlashcatUSB statut: Connecté à ({0} circuits)</value>
  </data>
  <data name="gui_fcusb_disconnected" xml:space="preserve">
    <value>FlashcatUSB statut: Déconnecté</value>
  </data>
  <data name="gui_fcusb_new_device" xml:space="preserve">
    <value>Nouveau circuit connecté: {0}</value>
  </data>
  <data name="gui_gand_erase_all_confirm" xml:space="preserve">
    <value>Cela va effacer tout le contenu du circuit flash. Confirmez-vous?</value>
  </data>
  <data name="gui_gane_write" xml:space="preserve">
    <value>Ecriture</value>
    <comment>Button to program data into multi devices</comment>
  </data>
  <data name="gui_gang_choose_binary" xml:space="preserve">
    <value>Choisissez un fichier binaire pour la programmation</value>
  </data>
  <data name="gui_gang_devices_programmed" xml:space="preserve">
    <value>Tous les circuits flash sont programmés</value>
  </data>
  <data name="gui_gang_device_busy" xml:space="preserve">
    <value>Un ou plusieurs circuit(s) occupé(s)</value>
  </data>
  <data name="gui_gang_erase" xml:space="preserve">
    <value>Effacement</value>
    <comment>Button to erase memory device</comment>
  </data>
  <data name="gui_gang_erase_complete" xml:space="preserve">
    <value>Tous les circuits flash sont effacés</value>
  </data>
  <data name="gui_gang_erasing" xml:space="preserve">
    <value>Effacement de tous les circuits flash</value>
  </data>
  <data name="gui_gang_info" xml:space="preserve">
    <value>Ceci est l'interface d'un outil de programmation multi-circuit</value>
  </data>
  <data name="gui_img_saved_to_disk" xml:space="preserve">
    <value>Image de la flash enregistrée sur le disque: {0}</value>
  </data>
  <data name="gui_img_successful" xml:space="preserve">
    <value>Image de la flash correctement programmée sur le circuit</value>
  </data>
  <data name="gui_memory_device" xml:space="preserve">
    <value>Circuit mémoire correctement effacé</value>
    <comment>The beginning label of each Flash memory device</comment>
  </data>
  <data name="gui_mem_device_status" xml:space="preserve">
    <value>Circuit {0}: Non connecté</value>
  </data>
  <data name="gui_mem_size" xml:space="preserve">
    <value>Taille de la mémoire flash</value>
  </data>
  <data name="gui_menu_language" xml:space="preserve">
    <value>Langue</value>
    <comment>Name of the Language menu</comment>
  </data>
  <data name="gui_menu_main" xml:space="preserve">
    <value>Menu Principal</value>
    <comment>Name of the Main menu</comment>
  </data>
  <data name="gui_menu_main_detect" xml:space="preserve">
    <value>Détection (re-initialise)</value>
    <comment>Detects any connected Flash device</comment>
  </data>
  <data name="gui_menu_main_exit" xml:space="preserve">
    <value>Quitter</value>
    <comment>Closes the application</comment>
  </data>
  <data name="gui_menu_main_refresh" xml:space="preserve">
    <value>Rafraîchi le circuit flash</value>
    <comment>Updates the hex editor</comment>
  </data>
  <data name="gui_menu_main_repeat" xml:space="preserve">
    <value>Répète l’opération d'écriture</value>
    <comment>Allows to repeat the last programming operation</comment>
  </data>
  <data name="gui_menu_mode" xml:space="preserve">
    <value>Mode</value>
    <comment>Name of the Mode menu</comment>
  </data>
  <data name="gui_menu_mode_bitswap" xml:space="preserve">
    <value>Permutation des bits</value>
  </data>
  <data name="gui_menu_mode_endian" xml:space="preserve">
    <value>Mode Endian</value>
  </data>
  <data name="gui_menu_mode_settings" xml:space="preserve">
    <value>Sélection du protocole</value>
    <comment>The settings form</comment>
  </data>
  <data name="gui_menu_mode_verify" xml:space="preserve">
    <value>Vérification de la programmation</value>
    <comment>Makes the software read and verify after programming data</comment>
  </data>
  <data name="gui_menu_mode_voltage" xml:space="preserve">
    <value>tension ({0})</value>
    <comment>Sets the voltage of FCUSB Pro</comment>
  </data>
  <data name="gui_menu_mode_vpp" xml:space="preserve">
    <value>Sélection de VPP</value>
  </data>
  <data name="gui_menu_script" xml:space="preserve">
    <value>Script</value>
    <comment>Name of the Script menu</comment>
  </data>
  <data name="gui_menu_script_load" xml:space="preserve">
    <value>Charge un script</value>
    <comment>Loads and runs a script file</comment>
  </data>
  <data name="gui_menu_script_select" xml:space="preserve">
    <value>Sélectionne un script</value>
    <comment>Chooses a script file</comment>
  </data>
  <data name="gui_menu_script_unload" xml:space="preserve">
    <value>Clôture un script</value>
    <comment>Removes the script file/tab</comment>
  </data>
  <data name="gui_menu_tools" xml:space="preserve">
    <value>Outils</value>
    <comment>Name of the Tools menu</comment>
  </data>
  <data name="gui_menu_tools_create" xml:space="preserve">
    <value>Crée une image</value>
    <comment>Reads and creates an image file</comment>
  </data>
  <data name="gui_menu_tools_erase" xml:space="preserve">
    <value>Efface la puce</value>
    <comment>Erase a Flash device</comment>
  </data>
  <data name="gui_menu_tools_mem_map" xml:space="preserve">
    <value>Carte mémoire NAND</value>
  </data>
  <data name="gui_menu_tools_spi_ecc" xml:space="preserve">
    <value>ECC interne SPI NAND</value>
  </data>
  <data name="gui_menu_tools_vendor" xml:space="preserve">
    <value>Caractéristiques fabriquant</value>
  </data>
  <data name="gui_menu_tools_write" xml:space="preserve">
    <value>Ecrit l'image</value>
    <comment>Programs an image file</comment>
  </data>
  <data name="gui_nand_creating_backup" xml:space="preserve">
    <value>Erreur lors de la création du backup: différences dans la mémoire relue</value>
  </data>
  <data name="gui_not_valid_img" xml:space="preserve">
    <value>Erreur: le fichier n'est pas une image flash valide</value>
  </data>
  <data name="gui_open_img" xml:space="preserve">
    <value>Ouvrir le fichier d'image flash à programmer</value>
  </data>
  <data name="gui_programming_img" xml:space="preserve">
    <value>Programmation de l'image flash: {0}</value>
  </data>
  <data name="gui_reading_flash" xml:space="preserve">
    <value>Lecture de la  Flash: {0} sur {1} octets ({2}% effectué)</value>
  </data>
  <data name="gui_reading_spare_area" xml:space="preserve">
    <value>Lecture de la zone de réserve NAND: {0} sur {1} octets ({2}% effectué)</value>
  </data>
  <data name="gui_repeat_beginning" xml:space="preserve">
    <value>Nouvelle opération d'écriture, reset du circuit</value>
  </data>
  <data name="gui_repeat_failed_detect" xml:space="preserve">
    <value>Erreur, impossible de détecter le circuit flash pour exécuter l'opération répétée</value>
  </data>
  <data name="gui_repeat_failed_reconnect" xml:space="preserve">
    <value>Erreur, impossible de se reconnecter au flashcatUSB</value>
  </data>
  <data name="gui_saved_img_to_disk" xml:space="preserve">
    <value>Image flash enregistrée sur le disque: {0}</value>
  </data>
  <data name="gui_save_dialog" xml:space="preserve">
    <value>Choisissez un emplacement pour enregistrer le fichier log de la console</value>
  </data>
  <data name="gui_script_can_not_load" xml:space="preserve">
    <value>Impossible de charger le script, le fichier n'existe pas</value>
  </data>
  <data name="gui_script_checking" xml:space="preserve">
    <value>Recherche d'un script spécifique du circuit à charger automatiquement</value>
  </data>
  <data name="gui_script_loaded" xml:space="preserve">
    <value>Script {0} chargé avec succès</value>
  </data>
  <data name="gui_script_loading" xml:space="preserve">
    <value>Chargement du script spécifique au circuit: {0}</value>
  </data>
  <data name="gui_script_non_available" xml:space="preserve">
    <value>Pas de fichier script disponible</value>
  </data>
  <data name="gui_script_open" xml:space="preserve">
    <value>Sélectionner le fichier script FlashcatUSB à ouvrir</value>
  </data>
  <data name="gui_script_reset" xml:space="preserve">
    <value>L'interpréteur de script FlashcatUSB a été réinitialisé</value>
  </data>
  <data name="gui_select_location" xml:space="preserve">
    <value>Sélectionner l'endroit où enregistrer l'image flash</value>
  </data>
  <data name="gui_status_welcome" xml:space="preserve">
    <value>Bienvenue sur FlashcatUSB (Logiciel de programmation SPI / I2C / JTAG)!</value>
  </data>
  <data name="gui_tab_console" xml:space="preserve">
    <value>Console</value>
    <comment>Name of the console tab</comment>
  </data>
  <data name="gui_tab_multi" xml:space="preserve">
    <value>Multi-circuit</value>
    <comment>Name of the gang programming tab</comment>
  </data>
  <data name="gui_tab_status" xml:space="preserve">
    <value>Statut</value>
    <comment>Name of the status tab</comment>
  </data>
  <data name="gui_vpp_confirm" xml:space="preserve">
    <value>Etes vous sur que vous voulez activer cette fonction?</value>
    <comment>To enable to the +12V feature</comment>
  </data>
  <data name="gui_vpp_setting" xml:space="preserve">
    <value>Confirmation du paramètre VPP +12V</value>
  </data>
  <data name="gui_vpp_warning" xml:space="preserve">
    <value>Attention, de paramètre ne doit être utilisé qu'avec un adaptateur ayant une commutateur +12V</value>
  </data>
  <data name="gui_writing_flash" xml:space="preserve">
    <value>Ecriture de la  Flash: {0} sur {1} bytes ({2}% effectué)</value>
  </data>
  <data name="mc_badnand_block" xml:space="preserve">
    <value>Mauvais bloc NAND à l’adresse: 0x{0} (Cartographié à 0x{1})</value>
  </data>
  <data name="mc_button_alldata" xml:space="preserve">
    <value>Conversion d'un fichier binaire au format INTEL HEX</value>
    <comment>The NAND memory area selection button (both main and spare areas)</comment>
  </data>
  <data name="mc_button_cancel" xml:space="preserve">
    <value>Toute Donnée</value>
  </data>
  <data name="mc_button_close" xml:space="preserve">
    <value>Annulation</value>
    <comment>The close button on the compare popup window</comment>
  </data>
  <data name="mc_button_compare" xml:space="preserve">
    <value>Fermer</value>
    <comment>The popup text when your move your cursor over the button</comment>
  </data>
  <data name="mc_button_erase" xml:space="preserve">
    <value>Compare le contenu de la mémoire</value>
    <comment>The popup text when your move your cursor over the button</comment>
  </data>
  <data name="mc_button_main" xml:space="preserve">
    <value>Efface toute la mémoire</value>
    <comment>The NAND memory area selection button (main part)</comment>
  </data>
  <data name="mc_button_ok" xml:space="preserve">
    <value>Zone Principale</value>
  </data>
  <data name="mc_button_read" xml:space="preserve">
    <value>OK</value>
    <comment>The popup text when your move your cursor over the button</comment>
  </data>
  <data name="mc_button_spare" xml:space="preserve">
    <value>Lecture de la mémoire vers le disque</value>
    <comment>The NAND memory area selection button (the spare or OOB)</comment>
  </data>
  <data name="mc_button_write" xml:space="preserve">
    <value>Zone de réserve</value>
    <comment>The popup text when your move your cursor over the button</comment>
  </data>
  <data name="mc_compare_canceled" xml:space="preserve">
    <value>Ecriture de données vers la mémoire</value>
  </data>
  <data name="mc_compare_complete_match" xml:space="preserve">
    <value>Comparaison de la mémoire annulée</value>
  </data>
  <data name="mc_compare_complete_tot" xml:space="preserve">
    <value>Comparaison de la mémoire terminée: {0}% de correspondance des données</value>
  </data>
  <data name="mc_compare_filename" xml:space="preserve">
    <value>Comparaison de la mémoire terminée: {0} erreurs en tout ({1}% de correspondances)</value>
  </data>
  <data name="mc_compare_flash_addr" xml:space="preserve">
    <value>Nom de fichier</value>
  </data>
  <data name="mc_compare_info" xml:space="preserve">
    <value>Adresse flash</value>
  </data>
  <data name="mc_compare_mismatch" xml:space="preserve">
    <value>Adresse flash: 0x{0}, taille: {1} octets</value>
  </data>
  <data name="mc_compare_results" xml:space="preserve">
    <value>Compteur d'erreurs: {0} octets ({1}% de correspondances)</value>
  </data>
  <data name="mc_compare_selected" xml:space="preserve">
    <value>Résultats de la comparaison de mémoire</value>
  </data>
  <data name="mc_compare_start" xml:space="preserve">
    <value>Fichier sélectionné, comparaison {0}</value>
  </data>
  <data name="mc_compare_total_processed" xml:space="preserve">
    <value>Début de l'opération de comparaison mémoire</value>
  </data>
  <data name="mc_erase_command_sent" xml:space="preserve">
    <value>Nombre total d'octets traités</value>
  </data>
  <data name="mc_erase_confirm" xml:space="preserve">
    <value>Envoie de la commande d'effacement mémoire au circuit: {0}</value>
  </data>
  <data name="mc_erase_warning" xml:space="preserve">
    <value>Confirmer l'effacement mémoire de {0}</value>
  </data>
  <data name="mc_io_destination" xml:space="preserve">
    <value>Cette action va effacer le données de façon définitive</value>
  </data>
  <data name="mc_io_file_cancel_to" xml:space="preserve">
    <value>Adresse ce la cible flash: 0x{0}, octets à écrire: {1} octets</value>
  </data>
  <data name="mc_io_file_choose" xml:space="preserve">
    <value>Annulation par l'utilisateur. Aucune donnée écrite sur {0}</value>
  </data>
  <data name="mc_io_file_compare" xml:space="preserve">
    <value>Choisir le fichier à écrire sur {0}</value>
  </data>
  <data name="mc_io_file_writing" xml:space="preserve">
    <value>Sélectionner le fichier à comparer avec la mémoire</value>
  </data>
  <data name="mc_io_open_file" xml:space="preserve">
    <value>Fichier sélectionné, écriture sur {0}</value>
  </data>
  <data name="mc_io_save_canceled" xml:space="preserve">
    <value>Fichier ouvert pour écriture: {0}, (taille: {1} octets)</value>
  </data>
  <data name="mc_io_save_type" xml:space="preserve">
    <value>Annulation par l'utilisateur. Aucune donnée n'a été sauvée.</value>
  </data>
  <data name="mc_mem_read_begin" xml:space="preserve">
    <value>Opération de lecture terminée</value>
  </data>
  <data name="mc_mem_read_canceled" xml:space="preserve">
    <value>Sélectionner la range pour la lecture des données depuis {0}</value>
  </data>
  <data name="mc_mem_read_done" xml:space="preserve">
    <value>Fichier ouvert pour écriture: {0} (Intel hex format), Taille totale: {1} octets</value>
  </data>
  <data name="mc_mem_read_from" xml:space="preserve">
    <value>Lu {0} octets en {1} secondes, {2}</value>
  </data>
  <data name="mc_mem_read_result" xml:space="preserve">
    <value>Opération de lecture en cours</value>
  </data>
  <data name="mc_mem_read_start" xml:space="preserve">
    <value>Adresse de début: {0} ({1}) Longueur: {2}</value>
  </data>
  <data name="mc_mem_start_addr" xml:space="preserve">
    <value>L'utilisateur a annulé l'opération de lecture</value>
  </data>
  <data name="mc_mem_user_cancel" xml:space="preserve">
    <value>Données lues converties au format Intel HEX pour enregistrement</value>
  </data>
  <data name="mc_mem_write_success" xml:space="preserve">
    <value>{0} enregistré sur le disque avec succès</value>
  </data>
  <data name="mc_reading" xml:space="preserve">
    <value>Lecture: {0} sur {1}</value>
  </data>
  <data name="mc_rngbox_base" xml:space="preserve">
    <value>Adresse de base</value>
    <comment>The flash address (starting point) of the operation</comment>
  </data>
  <data name="mc_rngbox_len" xml:space="preserve">
    <value>Longueur</value>
    <comment>The number of bytes to read/write</comment>
  </data>
  <data name="mc_select_range" xml:space="preserve">
    <value>Sélectionner la range pour l'écriture des données sur {0}</value>
  </data>
  <data name="mc_wr_oper_complete" xml:space="preserve">
    <value>Opération d'écriture terminée, {0} octets écrits</value>
  </data>
  <data name="mc_wr_oper_failed" xml:space="preserve">
    <value>L'opération d'écriture a échoué</value>
  </data>
  <data name="mc_wr_oper_file_err" xml:space="preserve">
    <value>Erreur, le fichier n'existe pas ou ne contient pas de données</value>
  </data>
  <data name="mc_wr_oper_result" xml:space="preserve">
    <value>{0} octets écrits {1} secondes, {2} octets/s</value>
  </data>
  <data name="mc_wr_oper_start" xml:space="preserve">
    <value>Opération d'écriture dans la mémoire en cours</value>
  </data>
  <data name="mc_wr_oper_status" xml:space="preserve">
    <value>Ecriture du fichier  {0} sur {1} ({2} octets à écrire)</value>
  </data>
  <data name="mc_wr_user_canceled" xml:space="preserve">
    <value>Opération d'écriture annulée par l'utilisateur</value>
  </data>
  <data name="mem_verify_data_at" xml:space="preserve">
    <value>Vérification des données écrites sur {0}</value>
  </data>
  <data name="settings_auto" xml:space="preserve">
    <value>Sélection des paramètres automatiquement</value>
    <comment>Use automatic SPI settings</comment>
  </data>
  <data name="settings_blk_disabled" xml:space="preserve">
    <value>Invalidé</value>
  </data>
  <data name="settings_box_block" xml:space="preserve">
    <value>Mauvais gestionnaire de bloc</value>
    <comment>The box for the block manager settings</comment>
  </data>
  <data name="settings_box_general" xml:space="preserve">
    <value>Général</value>
    <comment>The general / common group box</comment>
  </data>
  <data name="settings_box_layout" xml:space="preserve">
    <value>Disposition des zones Principale/Réserve</value>
    <comment>The box to specify how to define the main and spare NAND areas</comment>
  </data>
  <data name="settings_mismatch" xml:space="preserve">
    <value>Si erreur d'écriture, écrire les données sur le prochain bloc</value>
  </data>
  <data name="settings_preserve_mem" xml:space="preserve">
    <value>Conserve les zones de mémoire</value>
  </data>
  <data name="settings_read_cmd" xml:space="preserve">
    <value>Commande de lecture</value>
    <comment>SPI command to read data</comment>
  </data>
  <data name="settings_specify" xml:space="preserve">
    <value>Utiliser ces paramètres</value>
    <comment>Use specific SPI command op codes</comment>
  </data>
  <data name="cfi_flash_base" xml:space="preserve">
    <value>Adresse de base CFI Flash: 0x{0}</value>
  </data>
  <data name="cfi_flash_detected" xml:space="preserve">
    <value>Flash compatible CFI détectée sur 0x{0}</value>
  </data>
  <data name="cfi_flash_failed" xml:space="preserve">
    <value>Echec de la détection de flash compatible CFI</value>
  </data>
  <data name="cfi_flash_info" xml:space="preserve">
    <value>Description flash CFI: {0} ({1} octets)</value>
  </data>
  <data name="nand_reading_block" xml:space="preserve">
    <value>Lecture bloc NAND {0} sur {1} ({2}% effectué)</value>
  </data>
  <data name="settings_combined" xml:space="preserve">
    <value>Combiné</value>
    <comment>both the main and spare are combined to create a single area</comment>
  </data>
  <data name="settings_disable_ecc" xml:space="preserve">
    <value>Dévalide le générateur ECC SPI-NAND</value>
  </data>
  <data name="settings_nand_readverify" xml:space="preserve">
    <value>Utilise lecture-vérification lors de la création d'image</value>
  </data>
  <data name="settings_segmented" xml:space="preserve">
    <value>Segmenté</value>
    <comment>the sections are split up (main, then spare, the main, etc.)</comment>
  </data>
  <data name="settings_seperate" xml:space="preserve">
    <value>Séparé</value>
    <comment>seperage sections of the NAND page(main/spare areas)</comment>
  </data>
  <data name="nand_writing_block" xml:space="preserve">
    <value>Ecriture de block NAND {0} sur {1} ({2}% effectué)</value>
  </data>
  <data name="nand_completed_with_blocks_left" xml:space="preserve">
    <value>Ecriture de l'image terminée avec {0} bloc NAND non utilisés</value>
  </data>
  <data name="nand_missing_block" xml:space="preserve">
    <value>{0} blocks NAND manquant sur le fichier image</value>
  </data>
  <data name="settings_blk_1stbyte" xml:space="preserve">
    <value>1st byte:</value>
  </data>
  <data name="settings_blk_1stpage" xml:space="preserve">
    <value>Première page libre</value>
  </data>
  <data name="settings_blk_2ndpage" xml:space="preserve">
    <value>Deuxième page libre</value>
  </data>
  <data name="settings_blk_6thbyte" xml:space="preserve">
    <value>6ème octet:</value>
  </data>
  <data name="settings_blk_enabled" xml:space="preserve">
    <value>Validé (vérifie les marqueurs de mauvais blocs)</value>
  </data>
  <data name="settings_blk_lastpage" xml:space="preserve">
    <value>Dernière page libre</value>
  </data>
  <data name="mem_erase_failed_at" xml:space="preserve">
    <value>Echec de l'effacement de la flash à l'adresse: 0x{0} (sector index: {1})</value>
  </data>
  <data name="mem_erase_failed_title" xml:space="preserve">
    <value>Echec de l'effacement de la flash</value>
  </data>
  <data name="console_eeprom_not_specified" xml:space="preserve">
    <value>The circuit EEPROM que vous avez spécifié n'a pas été trouvé</value>
  </data>
  <data name="console_erase_not_valid" xml:space="preserve">
    <value>L'option d'effacement n'est valable que pour le mode -WRITE</value>
  </data>
  <data name="console_opt_erasechip" xml:space="preserve">
    <value>Efface le circuit mémoire en entier</value>
  </data>
  <data name="console_opt_not_valid" xml:space="preserve">
    <value>Option non reconnue: {0}</value>
  </data>
  <data name="console_value_missing" xml:space="preserve">
    <value>Vous devez spécifier une valeur suivant -{0}</value>
  </data>
  <data name="console_value_numeric_hex" xml:space="preserve">
    <value>la valeur - {0}  doit être numérique ou hexadécimale</value>
  </data>
  <data name="nandmngr_analyze" xml:space="preserve">
    <value>Analyse</value>
    <comment>Text for the button to check the entire flash for bad blocks</comment>
  </data>
  <data name="nandmngr_analyzed_done" xml:space="preserve">
    <value>Blocks NAND analysés ({0} mauvais blocs trouvés)</value>
  </data>
  <data name="nandmngr_bad_block" xml:space="preserve">
    <value>Mauvais marqueur de blocs</value>
    <comment>Icon used for invalid block</comment>
  </data>
  <data name="nandmngr_bad_marker" xml:space="preserve">
    <value>mauvai marqueur</value>
  </data>
  <data name="nandmngr_block_map" xml:space="preserve">
    <value>Carte des blocs NAND ({0} total blocs; {1} octets chacun)</value>
  </data>
  <data name="nandmngr_close" xml:space="preserve">
    <value>Quitter</value>
    <comment>Close the block manager form</comment>
  </data>
  <data name="nandmngr_confim" xml:space="preserve">
    <value>Confirmer l’opération</value>
  </data>
  <data name="nandmngr_no_error" xml:space="preserve">
    <value>Pas d'Erreur</value>
    <comment>Icon used for valid block</comment>
  </data>
  <data name="nandmngr_selected_page" xml:space="preserve">
    <value>Page sélectionnée: {0} [bloc: {1}]</value>
  </data>
  <data name="nandmngr_title" xml:space="preserve">
    <value>Gestion des blocs NAND ({0})</value>
  </data>
  <data name="nandmngr_user_discarded" xml:space="preserve">
    <value>Rejeté par l'utilisateur</value>
    <comment>The user selected this block to ignore</comment>
  </data>
  <data name="nandmngr_user_marked" xml:space="preserve">
    <value>Marqué par l'utilisateur</value>
    <comment>Icon used for user marked block to not use</comment>
  </data>
  <data name="nandmngr_valid" xml:space="preserve">
    <value>Valide</value>
    <comment>Indicates the block is valid</comment>
  </data>
  <data name="nandmngr_verifing_block" xml:space="preserve">
    <value>Vérification du  bloc: {0}</value>
  </data>
  <data name="nandmngr_warning" xml:space="preserve">
    <value>Avertissement, cette opération va effacer et réécrire tous les blocs, continuer?</value>
  </data>
  <data name="nandmngr_write_error" xml:space="preserve">
    <value>Erreur d'écriture</value>
    <comment>Icon used for block that failed write/read</comment>
  </data>
  <data name="nandmngr_write_marker" xml:space="preserve">
    <value>Ecrire les flags de mauvais blocs dans la zone de réserve</value>
    <comment>Text for checkbox to have the software write data flags</comment>
  </data>
  <data name="mc_mem_converting_format" xml:space="preserve">
    <value>Choisir l'emplacement sur le disque dur et le format de données</value>
  </data>
  <data name="mc_mem_incorrect_format" xml:space="preserve">
    <value>Début  de lecture de la mémoire à {0}</value>
  </data>
  <data name="mc_mem_open_file_write" xml:space="preserve">
    <value>Opération de lecture annulée</value>
  </data>
  <data name="nandecc_algorithm" xml:space="preserve">
    <value>Algorithme</value>
  </data>
  <data name="nandecc_biterror" xml:space="preserve">
    <value>Erreur binaire</value>
  </data>
  <data name="nandecc_changes" xml:space="preserve">
    <value>Changements * prennent effet lors d'un événement de détection du circuit</value>
  </data>
  <data name="nandecc_ecclocation" xml:space="preserve">
    <value>Emplacement ECC</value>
  </data>
  <data name="nandecc_enabled" xml:space="preserve">
    <value>Activé</value>
  </data>
  <data name="nandecc_read_operation" xml:space="preserve">
    <value>Opération de lecture (auto-correction)</value>
  </data>
  <data name="nandecc_write_operation" xml:space="preserve">
    <value>Opération d'écriture (Ecriture ECC)</value>
  </data>
  <data name="nandecc_groupbox" xml:space="preserve">
    <value>Fonction ECC du logiciel</value>
  </data>
  <data name="nandecc_revbyteorder" xml:space="preserve">
    <value>Inverser l'ordre des octets</value>
  </data>
  <data name="nandecc_symwidth" xml:space="preserve">
    <value>Largeur du symbole</value>
  </data>
</root>